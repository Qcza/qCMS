"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require('@angular/core');
var nextId = 0;
/**
 * Represents an individual slide to be used within a carousel.
 */
var NgbSlide = (function () {
    function NgbSlide(tplRef) {
        this.tplRef = tplRef;
        /**
         * Unique slide identifier. Must be unique for the entire document for proper accessibility support.
         * Will be auto-generated if not provided.
         */
        this.id = "ngb-slide-" + nextId++;
    }
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object)
    ], NgbSlide.prototype, "id", void 0);
    NgbSlide = __decorate([
        core_1.Directive({ selector: 'template[ngbSlide]' }), 
        __metadata('design:paramtypes', [core_1.TemplateRef])
    ], NgbSlide);
    return NgbSlide;
}());
exports.NgbSlide = NgbSlide;
/**
 * Directive to easily create carousels based on Bootstrap's markup.
 */
var NgbCarousel = (function () {
    function NgbCarousel() {
        /**
         *  Amount of time in milliseconds before next slide is shown.
         */
        this.interval = 5000;
        /**
         *  Whether can wrap from the last to the first slide.
         */
        this.wrap = true;
        /**
         *  A flag for allowing navigation via keyboard
         */
        this.keyboard = true;
    }
    NgbCarousel.prototype.ngAfterContentChecked = function () {
        var activeSlide = this._getSlideById(this.activeId);
        this.activeId = activeSlide ? activeSlide.id : (this._slides.length ? this._slides.first.id : null);
    };
    NgbCarousel.prototype.ngOnInit = function () { this._startTimer(); };
    NgbCarousel.prototype.ngOnDestroy = function () { clearInterval(this._slideChangeInterval); };
    /**
     * Navigate to a slide with a specified identifier.
     */
    NgbCarousel.prototype.select = function (slideIdx) {
        this._cycleToSelected(slideIdx);
        this._restartTimer();
    };
    /**
     * Navigate to the next slide.
     */
    NgbCarousel.prototype.prev = function () {
        this._cycleToPrev();
        this._restartTimer();
    };
    /**
     * Navigate to the next slide.
     */
    NgbCarousel.prototype.next = function () {
        this._cycleToNext();
        this._restartTimer();
    };
    /**
     * Stops the carousel from cycling through items.
     */
    NgbCarousel.prototype.pause = function () { this._stopTimer(); };
    /**
     * Restarts cycling through the carousel slides from left to right.
     */
    NgbCarousel.prototype.cycle = function () { this._startTimer(); };
    NgbCarousel.prototype._keyPrev = function () {
        if (this.keyboard) {
            this.prev();
        }
    };
    NgbCarousel.prototype._keyNext = function () {
        if (this.keyboard) {
            this.next();
        }
    };
    NgbCarousel.prototype._cycleToNext = function () {
        var selectedId = this._getNextSlide(this.activeId);
        this._cycleToSelected(selectedId);
    };
    NgbCarousel.prototype._cycleToPrev = function () {
        var selectedId = this._getPrevSlide(this.activeId);
        this._cycleToSelected(selectedId);
    };
    NgbCarousel.prototype._cycleToSelected = function (slideIdx) {
        var selectedSlide = this._getSlideById(slideIdx);
        if (selectedSlide) {
            this.activeId = selectedSlide.id;
        }
    };
    NgbCarousel.prototype._restartTimer = function () {
        this._stopTimer();
        this._startTimer();
    };
    NgbCarousel.prototype._startTimer = function () {
        var _this = this;
        this._slideChangeInterval = setInterval(function () { _this._cycleToNext(); }, this.interval);
    };
    NgbCarousel.prototype._stopTimer = function () { clearInterval(this._slideChangeInterval); };
    NgbCarousel.prototype._getSlideById = function (slideIdx) {
        var slideWithId = this._slides.filter(function (slide) { return slide.id === slideIdx; });
        return slideWithId.length ? slideWithId[0] : null;
    };
    NgbCarousel.prototype._getNextSlide = function (id) {
        var _this = this;
        var nextSlideId = id;
        var slideArr = this._slides.toArray();
        slideArr.forEach(function (slide, idx) {
            if (slide.id === id) {
                var lastSlide = (idx === (slideArr.length - 1));
                nextSlideId =
                    lastSlide ? (_this.wrap ? slideArr[0].id : slideArr[slideArr.length - 1].id) : slideArr[idx + 1].id;
            }
        });
        return nextSlideId;
    };
    NgbCarousel.prototype._getPrevSlide = function (id) {
        var _this = this;
        var prevSlideId = id;
        var slideArr = this._slides.toArray();
        slideArr.forEach(function (slide, idx) {
            if (slide.id === id) {
                prevSlideId =
                    idx === 0 ? (_this.wrap ? slideArr[slideArr.length - 1].id : slideArr[0].id) : slideArr[idx - 1].id;
            }
        });
        return prevSlideId;
    };
    __decorate([
        core_1.ContentChildren(NgbSlide), 
        __metadata('design:type', core_1.QueryList)
    ], NgbCarousel.prototype, "_slides", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object)
    ], NgbCarousel.prototype, "interval", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object)
    ], NgbCarousel.prototype, "wrap", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', Object)
    ], NgbCarousel.prototype, "keyboard", void 0);
    __decorate([
        core_1.Input(), 
        __metadata('design:type', String)
    ], NgbCarousel.prototype, "activeId", void 0);
    NgbCarousel = __decorate([
        core_1.Component({
            selector: 'ngb-carousel',
            exportAs: 'ngbCarousel',
            host: {
                'class': 'carousel slide',
                '[style.display]': '"block"',
                'tabIndex': '0',
                '(mouseenter)': 'pause()',
                '(mouseleave)': 'cycle()',
                '(keyup.arrowLeft)': '_keyPrev()',
                '(keyup.arrowRight)': '_keyNext()'
            },
            template: "\n    <ol class=\"carousel-indicators\">\n      <li *ngFor=\"let slide of _slides\" [id]=\"slide.id\" [class.active]=\"slide.id === activeId\" (click)=\"_cycleToSelected(slide.id)\"></li>\n    </ol>\n    <div class=\"carousel-inner\" role=\"listbox\">\n      <div *ngFor=\"let slide of _slides\" class=\"carousel-item\" [class.active]=\"slide.id === activeId\">\n        <template [ngTemplateOutlet]=\"slide.tplRef\"></template>\n      </div>\n    </div>\n    <a class=\"left carousel-control\" role=\"button\" (click)=\"_cycleToPrev()\">\n      <span class=\"icon-prev\" aria-hidden=\"true\"></span>\n      <span class=\"sr-only\">Previous</span>\n    </a>\n    <a class=\"right carousel-control\" role=\"button\" (click)=\"_cycleToNext()\">\n      <span class=\"icon-next\" aria-hidden=\"true\"></span>\n      <span class=\"sr-only\">Next</span>\n    </a>\n    "
        }), 
        __metadata('design:paramtypes', [])
    ], NgbCarousel);
    return NgbCarousel;
}());
exports.NgbCarousel = NgbCarousel;
exports.NGB_CAROUSEL_DIRECTIVES = [NgbCarousel, NgbSlide];

//# sourceMappingURL=carousel.js.map
